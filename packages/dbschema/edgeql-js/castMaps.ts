// GENERATED by @gel/generate v0.6.2

import * as gel from "gel";
import type * as $ from "./reflection";
import * as literal from "./literal";
import type * as _std from "./modules/std";
import type * as _users from "./modules/users";
import type * as _training from "./modules/training";
import type * as _sys from "./modules/sys";
import type * as _stdpg from "./modules/std/pg";
import type * as _stdnethttp from "./modules/std/net/http";
import type * as _stdnet from "./modules/std/net";
import type * as _stdfts from "./modules/std/fts";
import type * as _stdenc from "./modules/std/enc";
import type * as _stdcal from "./modules/std/cal";
import type * as _sign_in from "./modules/sign_in";
import type * as _schema from "./modules/schema";
import type * as _notification from "./modules/notification";
import type * as _extauth from "./modules/ext/auth";
import type * as _event from "./modules/event";
import type * as _cfg from "./modules/cfg";
export type scalarAssignableBy<T extends $.ScalarType> =
  T extends _std.$number ? _std.$number : 
  T extends _users.$RepStatus ? _users.$RepStatus : 
  T extends _users.$Platform ? _users.$Platform : 
  T extends _users.$InfractionType ? _users.$InfractionType : 
  T extends _training.$Selectability ? _training.$Selectability : 
  T extends _training.$LocationName ? _training.$LocationName : 
  T extends _training.$AnswerType ? _training.$AnswerType : 
  T extends _sys.$VersionStage ? _sys.$VersionStage : 
  T extends _sys.$TransactionIsolation ? _sys.$TransactionIsolation : 
  T extends _sys.$TransactionDeferrability ? _sys.$TransactionDeferrability : 
  T extends _sys.$TransactionAccessMode ? _sys.$TransactionAccessMode : 
  T extends _sys.$QueryType ? _sys.$QueryType : 
  T extends _sys.$OutputFormat ? _sys.$OutputFormat : 
  T extends _std.$uuid ? _std.$uuid : 
  T extends _std.$str ? _std.$str : 
  T extends _stdpg.$timestamptz ? _stdpg.$timestamptz : 
  T extends _stdpg.$timestamp ? _stdpg.$timestamp : 
  T extends _stdpg.$json ? _stdpg.$json : 
  T extends _stdpg.$interval ? _stdpg.$interval : 
  T extends _stdpg.$date ? _stdpg.$date : 
  T extends _stdnethttp.$Method ? _stdnethttp.$Method : 
  T extends _stdnet.$RequestState ? _stdnet.$RequestState : 
  T extends _stdnet.$RequestFailureKind ? _stdnet.$RequestFailureKind : 
  T extends _std.$json ? _std.$json : 
  T extends _std.$int64 ? _std.$int64 : 
  T extends _std.$int32 ? _std.$int32 : 
  T extends _std.$int16 ? _std.$int16 : 
  T extends _stdfts.$document ? _stdfts.$document : 
  T extends _stdfts.$Weight ? _stdfts.$Weight : 
  T extends _stdfts.$PGLanguage ? _stdfts.$PGLanguage : 
  T extends _stdfts.$LuceneLanguage ? _stdfts.$LuceneLanguage : 
  T extends _stdfts.$Language ? _stdfts.$Language : 
  T extends _stdfts.$ElasticLanguage ? _stdfts.$ElasticLanguage : 
  T extends _std.$float64 ? _std.$float64 : 
  T extends _std.$float32 ? _std.$float32 : 
  T extends _stdenc.$Base64Alphabet ? _stdenc.$Base64Alphabet : 
  T extends _std.$duration ? _std.$duration : 
  T extends _std.$decimal ? _std.$decimalλIAssignableBy : 
  T extends _std.$datetime ? _std.$datetime : 
  T extends _stdcal.$relative_duration ? _stdcal.$relative_durationλIAssignableBy : 
  T extends _stdcal.$local_time ? _stdcal.$local_time : 
  T extends _stdcal.$local_datetime ? _stdcal.$local_datetimeλIAssignableBy : 
  T extends _stdcal.$local_date ? _stdcal.$local_date : 
  T extends _stdcal.$date_duration ? _stdcal.$date_duration : 
  T extends _std.$bytes ? _std.$bytes : 
  T extends _std.$bool ? _std.$bool : 
  T extends _std.$bigint ? _std.$bigint : 
  T extends _std.$JsonEmpty ? _std.$JsonEmpty : 
  T extends _std.$Endian ? _std.$Endian : 
  T extends _sign_in.$ReasonCategory ? _sign_in.$ReasonCategory : 
  T extends _sign_in.$LocationStatus ? _sign_in.$LocationStatus : 
  T extends _sign_in.$LocationName ? _sign_in.$LocationName : 
  T extends _schema.$Volatility ? _schema.$Volatility : 
  T extends _schema.$TypeModifier ? _schema.$TypeModifier : 
  T extends _schema.$TriggerTiming ? _schema.$TriggerTiming : 
  T extends _schema.$TriggerScope ? _schema.$TriggerScope : 
  T extends _schema.$TriggerKind ? _schema.$TriggerKind : 
  T extends _schema.$TargetDeleteAction ? _schema.$TargetDeleteAction : 
  T extends _schema.$SourceDeleteAction ? _schema.$SourceDeleteAction : 
  T extends _schema.$RewriteKind ? _schema.$RewriteKind : 
  T extends _schema.$ParameterKind ? _schema.$ParameterKind : 
  T extends _schema.$OperatorKind ? _schema.$OperatorKind : 
  T extends _schema.$MigrationGeneratedBy ? _schema.$MigrationGeneratedBy : 
  T extends _schema.$IndexDeferrability ? _schema.$IndexDeferrability : 
  T extends _schema.$Cardinality ? _schema.$Cardinality : 
  T extends _schema.$AccessPolicyAction ? _schema.$AccessPolicyAction : 
  T extends _schema.$AccessKind ? _schema.$AccessKind : 
  T extends _notification.$Type ? _notification.$Type : 
  T extends _notification.$Status ? _notification.$Status : 
  T extends _notification.$DeliveryMethod ? _notification.$DeliveryMethod : 
  T extends _notification.$AllTargetTarget ? _notification.$AllTargetTarget : 
  T extends _extauth.$WebhookEvent ? _extauth.$WebhookEvent : 
  T extends _extauth.$JWTAlgo ? _extauth.$JWTAlgo : 
  T extends _extauth.$FlowType ? _extauth.$FlowType : 
  T extends _event.$EventType ? _event.$EventType : 
  T extends _cfg.$memory ? _cfg.$memory : 
  T extends _cfg.$StoreMigrationSDL ? _cfg.$StoreMigrationSDL : 
  T extends _cfg.$SMTPSecurity ? _cfg.$SMTPSecurity : 
  T extends _cfg.$QueryStatsOption ? _cfg.$QueryStatsOption : 
  T extends _cfg.$QueryCacheMode ? _cfg.$QueryCacheMode : 
  T extends _cfg.$ConnectionTransport ? _cfg.$ConnectionTransport : 
  T extends _cfg.$AllowBareDDL ? _cfg.$AllowBareDDL : 
  never

export type scalarCastableFrom<T extends $.ScalarType> =
  T extends _std.$number ? _std.$number : 
  T extends _users.$RepStatus ? _users.$RepStatus : 
  T extends _users.$Platform ? _users.$Platform : 
  T extends _users.$InfractionType ? _users.$InfractionType : 
  T extends _training.$Selectability ? _training.$Selectability : 
  T extends _training.$LocationName ? _training.$LocationName : 
  T extends _training.$AnswerType ? _training.$AnswerType : 
  T extends _sys.$VersionStage ? _sys.$VersionStage : 
  T extends _sys.$TransactionIsolation ? _sys.$TransactionIsolation : 
  T extends _sys.$TransactionDeferrability ? _sys.$TransactionDeferrability : 
  T extends _sys.$TransactionAccessMode ? _sys.$TransactionAccessMode : 
  T extends _sys.$QueryType ? _sys.$QueryType : 
  T extends _sys.$OutputFormat ? _sys.$OutputFormat : 
  T extends _std.$uuid ? _std.$uuid : 
  T extends _std.$str ? _std.$str : 
  T extends _stdpg.$timestamptz ? _stdpg.$timestamptz : 
  T extends _stdpg.$timestamp ? _stdpg.$timestamp : 
  T extends _stdpg.$json ? _stdpg.$json : 
  T extends _stdpg.$interval ? _stdpg.$interval : 
  T extends _stdpg.$date ? _stdpg.$date : 
  T extends _stdnethttp.$Method ? _stdnethttp.$Method : 
  T extends _stdnet.$RequestState ? _stdnet.$RequestState : 
  T extends _stdnet.$RequestFailureKind ? _stdnet.$RequestFailureKind : 
  T extends _std.$json ? _std.$json : 
  T extends _std.$int64 ? _std.$int64 : 
  T extends _std.$int32 ? _std.$int32 : 
  T extends _std.$int16 ? _std.$int16 : 
  T extends _stdfts.$document ? _stdfts.$document : 
  T extends _stdfts.$Weight ? _stdfts.$Weight : 
  T extends _stdfts.$PGLanguage ? _stdfts.$PGLanguage : 
  T extends _stdfts.$LuceneLanguage ? _stdfts.$LuceneLanguage : 
  T extends _stdfts.$Language ? _stdfts.$Language : 
  T extends _stdfts.$ElasticLanguage ? _stdfts.$ElasticLanguage : 
  T extends _std.$float64 ? _std.$float64 : 
  T extends _std.$float32 ? _std.$float32 : 
  T extends _stdenc.$Base64Alphabet ? _stdenc.$Base64Alphabet : 
  T extends _std.$duration ? _std.$duration : 
  T extends _std.$decimal ? _std.$decimalλICastableTo : 
  T extends _std.$datetime ? _std.$datetime : 
  T extends _stdcal.$relative_duration ? _stdcal.$relative_durationλICastableTo : 
  T extends _stdcal.$local_time ? _stdcal.$local_time : 
  T extends _stdcal.$local_datetime ? _stdcal.$local_datetimeλICastableTo : 
  T extends _stdcal.$local_date ? _stdcal.$local_date : 
  T extends _stdcal.$date_duration ? _stdcal.$date_duration : 
  T extends _std.$bytes ? _std.$bytes : 
  T extends _std.$bool ? _std.$bool : 
  T extends _std.$bigint ? _std.$bigint : 
  T extends _std.$JsonEmpty ? _std.$JsonEmpty : 
  T extends _std.$Endian ? _std.$Endian : 
  T extends _sign_in.$ReasonCategory ? _sign_in.$ReasonCategory : 
  T extends _sign_in.$LocationStatus ? _sign_in.$LocationStatus : 
  T extends _sign_in.$LocationName ? _sign_in.$LocationName : 
  T extends _schema.$Volatility ? _schema.$Volatility : 
  T extends _schema.$TypeModifier ? _schema.$TypeModifier : 
  T extends _schema.$TriggerTiming ? _schema.$TriggerTiming : 
  T extends _schema.$TriggerScope ? _schema.$TriggerScope : 
  T extends _schema.$TriggerKind ? _schema.$TriggerKind : 
  T extends _schema.$TargetDeleteAction ? _schema.$TargetDeleteAction : 
  T extends _schema.$SourceDeleteAction ? _schema.$SourceDeleteAction : 
  T extends _schema.$RewriteKind ? _schema.$RewriteKind : 
  T extends _schema.$ParameterKind ? _schema.$ParameterKind : 
  T extends _schema.$OperatorKind ? _schema.$OperatorKind : 
  T extends _schema.$MigrationGeneratedBy ? _schema.$MigrationGeneratedBy : 
  T extends _schema.$IndexDeferrability ? _schema.$IndexDeferrability : 
  T extends _schema.$Cardinality ? _schema.$Cardinality : 
  T extends _schema.$AccessPolicyAction ? _schema.$AccessPolicyAction : 
  T extends _schema.$AccessKind ? _schema.$AccessKind : 
  T extends _notification.$Type ? _notification.$Type : 
  T extends _notification.$Status ? _notification.$Status : 
  T extends _notification.$DeliveryMethod ? _notification.$DeliveryMethod : 
  T extends _notification.$AllTargetTarget ? _notification.$AllTargetTarget : 
  T extends _extauth.$WebhookEvent ? _extauth.$WebhookEvent : 
  T extends _extauth.$JWTAlgo ? _extauth.$JWTAlgo : 
  T extends _extauth.$FlowType ? _extauth.$FlowType : 
  T extends _event.$EventType ? _event.$EventType : 
  T extends _cfg.$memory ? _cfg.$memory : 
  T extends _cfg.$StoreMigrationSDL ? _cfg.$StoreMigrationSDL : 
  T extends _cfg.$SMTPSecurity ? _cfg.$SMTPSecurity : 
  T extends _cfg.$QueryStatsOption ? _cfg.$QueryStatsOption : 
  T extends _cfg.$QueryCacheMode ? _cfg.$QueryCacheMode : 
  T extends _cfg.$ConnectionTransport ? _cfg.$ConnectionTransport : 
  T extends _cfg.$AllowBareDDL ? _cfg.$AllowBareDDL : 
  never

type getSharedParentScalar<A, B> =
  A extends _std.$number ?
    B extends _std.$number ?
    B
    :
    never
  :
  A extends _users.$RepStatus ?
    B extends _users.$RepStatus ?
    B
    :
    never
  :
  A extends _users.$Platform ?
    B extends _users.$Platform ?
    B
    :
    never
  :
  A extends _users.$InfractionType ?
    B extends _users.$InfractionType ?
    B
    :
    never
  :
  A extends _training.$Selectability ?
    B extends _training.$Selectability ?
    B
    :
    never
  :
  A extends _training.$LocationName ?
    B extends _training.$LocationName ?
    B
    :
    never
  :
  A extends _training.$AnswerType ?
    B extends _training.$AnswerType ?
    B
    :
    never
  :
  A extends _sys.$VersionStage ?
    B extends _sys.$VersionStage ?
    B
    :
    never
  :
  A extends _sys.$TransactionIsolation ?
    B extends _sys.$TransactionIsolation ?
    B
    :
    never
  :
  A extends _sys.$TransactionDeferrability ?
    B extends _sys.$TransactionDeferrability ?
    B
    :
    never
  :
  A extends _sys.$TransactionAccessMode ?
    B extends _sys.$TransactionAccessMode ?
    B
    :
    never
  :
  A extends _sys.$QueryType ?
    B extends _sys.$QueryType ?
    B
    :
    never
  :
  A extends _sys.$OutputFormat ?
    B extends _sys.$OutputFormat ?
    B
    :
    never
  :
  A extends _std.$uuid ?
    B extends _std.$uuid ?
    B
    :
    never
  :
  A extends _std.$str ?
    B extends _std.$str ?
    B
    :
    never
  :
  A extends _stdpg.$timestamptz ?
    B extends _stdpg.$timestamptz ?
    B
    :
    never
  :
  A extends _stdpg.$timestamp ?
    B extends _stdpg.$timestamp ?
    B
    :
    never
  :
  A extends _stdpg.$json ?
    B extends _stdpg.$json ?
    B
    :
    never
  :
  A extends _stdpg.$interval ?
    B extends _stdpg.$interval ?
    B
    :
    never
  :
  A extends _stdpg.$date ?
    B extends _stdpg.$date ?
    B
    :
    never
  :
  A extends _stdnethttp.$Method ?
    B extends _stdnethttp.$Method ?
    B
    :
    never
  :
  A extends _stdnet.$RequestState ?
    B extends _stdnet.$RequestState ?
    B
    :
    never
  :
  A extends _stdnet.$RequestFailureKind ?
    B extends _stdnet.$RequestFailureKind ?
    B
    :
    never
  :
  A extends _std.$json ?
    B extends _std.$json ?
    B
    :
    never
  :
  A extends _std.$int64 ?
    B extends _std.$int64 ?
    B
    :
    never
  :
  A extends _std.$int32 ?
    B extends _std.$int32 ?
    B
    :
    never
  :
  A extends _std.$int16 ?
    B extends _std.$int16 ?
    B
    :
    never
  :
  A extends _stdfts.$document ?
    B extends _stdfts.$document ?
    B
    :
    never
  :
  A extends _stdfts.$Weight ?
    B extends _stdfts.$Weight ?
    B
    :
    never
  :
  A extends _stdfts.$PGLanguage ?
    B extends _stdfts.$PGLanguage ?
    B
    :
    never
  :
  A extends _stdfts.$LuceneLanguage ?
    B extends _stdfts.$LuceneLanguage ?
    B
    :
    never
  :
  A extends _stdfts.$Language ?
    B extends _stdfts.$Language ?
    B
    :
    never
  :
  A extends _stdfts.$ElasticLanguage ?
    B extends _stdfts.$ElasticLanguage ?
    B
    :
    never
  :
  A extends _std.$float64 ?
    B extends _std.$float64 ?
    B
    :
    never
  :
  A extends _std.$float32 ?
    B extends _std.$float32 ?
    B
    :
    never
  :
  A extends _stdenc.$Base64Alphabet ?
    B extends _stdenc.$Base64Alphabet ?
    B
    :
    never
  :
  A extends _std.$duration ?
    B extends _std.$duration ?
    B
    :
    never
  :
  A extends _std.$decimal ?
    B extends _std.$decimal ?
    B
    :
    B extends _std.$bigint ?
    A
    :
    never
  :
  A extends _std.$datetime ?
    B extends _std.$datetime ?
    B
    :
    never
  :
  A extends _stdcal.$relative_duration ?
    B extends _stdcal.$relative_duration ?
    B
    :
    B extends _stdcal.$date_duration ?
    A
    :
    never
  :
  A extends _stdcal.$local_time ?
    B extends _stdcal.$local_time ?
    B
    :
    never
  :
  A extends _stdcal.$local_datetime ?
    B extends _stdcal.$local_datetime ?
    B
    :
    B extends _stdcal.$local_date ?
    A
    :
    never
  :
  A extends _stdcal.$local_date ?
    B extends _stdcal.$local_datetime ?
    B
    :
    B extends _stdcal.$local_date ?
    B
    :
    never
  :
  A extends _stdcal.$date_duration ?
    B extends _stdcal.$relative_duration ?
    B
    :
    B extends _stdcal.$date_duration ?
    B
    :
    never
  :
  A extends _std.$bytes ?
    B extends _std.$bytes ?
    B
    :
    never
  :
  A extends _std.$bool ?
    B extends _std.$bool ?
    B
    :
    never
  :
  A extends _std.$bigint ?
    B extends _std.$decimal ?
    B
    :
    B extends _std.$bigint ?
    B
    :
    never
  :
  A extends _std.$JsonEmpty ?
    B extends _std.$JsonEmpty ?
    B
    :
    never
  :
  A extends _std.$Endian ?
    B extends _std.$Endian ?
    B
    :
    never
  :
  A extends _sign_in.$ReasonCategory ?
    B extends _sign_in.$ReasonCategory ?
    B
    :
    never
  :
  A extends _sign_in.$LocationStatus ?
    B extends _sign_in.$LocationStatus ?
    B
    :
    never
  :
  A extends _sign_in.$LocationName ?
    B extends _sign_in.$LocationName ?
    B
    :
    never
  :
  A extends _schema.$Volatility ?
    B extends _schema.$Volatility ?
    B
    :
    never
  :
  A extends _schema.$TypeModifier ?
    B extends _schema.$TypeModifier ?
    B
    :
    never
  :
  A extends _schema.$TriggerTiming ?
    B extends _schema.$TriggerTiming ?
    B
    :
    never
  :
  A extends _schema.$TriggerScope ?
    B extends _schema.$TriggerScope ?
    B
    :
    never
  :
  A extends _schema.$TriggerKind ?
    B extends _schema.$TriggerKind ?
    B
    :
    never
  :
  A extends _schema.$TargetDeleteAction ?
    B extends _schema.$TargetDeleteAction ?
    B
    :
    never
  :
  A extends _schema.$SourceDeleteAction ?
    B extends _schema.$SourceDeleteAction ?
    B
    :
    never
  :
  A extends _schema.$RewriteKind ?
    B extends _schema.$RewriteKind ?
    B
    :
    never
  :
  A extends _schema.$ParameterKind ?
    B extends _schema.$ParameterKind ?
    B
    :
    never
  :
  A extends _schema.$OperatorKind ?
    B extends _schema.$OperatorKind ?
    B
    :
    never
  :
  A extends _schema.$MigrationGeneratedBy ?
    B extends _schema.$MigrationGeneratedBy ?
    B
    :
    never
  :
  A extends _schema.$IndexDeferrability ?
    B extends _schema.$IndexDeferrability ?
    B
    :
    never
  :
  A extends _schema.$Cardinality ?
    B extends _schema.$Cardinality ?
    B
    :
    never
  :
  A extends _schema.$AccessPolicyAction ?
    B extends _schema.$AccessPolicyAction ?
    B
    :
    never
  :
  A extends _schema.$AccessKind ?
    B extends _schema.$AccessKind ?
    B
    :
    never
  :
  A extends _notification.$Type ?
    B extends _notification.$Type ?
    B
    :
    never
  :
  A extends _notification.$Status ?
    B extends _notification.$Status ?
    B
    :
    never
  :
  A extends _notification.$DeliveryMethod ?
    B extends _notification.$DeliveryMethod ?
    B
    :
    never
  :
  A extends _notification.$AllTargetTarget ?
    B extends _notification.$AllTargetTarget ?
    B
    :
    never
  :
  A extends _extauth.$WebhookEvent ?
    B extends _extauth.$WebhookEvent ?
    B
    :
    never
  :
  A extends _extauth.$JWTAlgo ?
    B extends _extauth.$JWTAlgo ?
    B
    :
    never
  :
  A extends _extauth.$FlowType ?
    B extends _extauth.$FlowType ?
    B
    :
    never
  :
  A extends _event.$EventType ?
    B extends _event.$EventType ?
    B
    :
    never
  :
  A extends _cfg.$memory ?
    B extends _cfg.$memory ?
    B
    :
    never
  :
  A extends _cfg.$StoreMigrationSDL ?
    B extends _cfg.$StoreMigrationSDL ?
    B
    :
    never
  :
  A extends _cfg.$SMTPSecurity ?
    B extends _cfg.$SMTPSecurity ?
    B
    :
    never
  :
  A extends _cfg.$QueryStatsOption ?
    B extends _cfg.$QueryStatsOption ?
    B
    :
    never
  :
  A extends _cfg.$QueryCacheMode ?
    B extends _cfg.$QueryCacheMode ?
    B
    :
    never
  :
  A extends _cfg.$ConnectionTransport ?
    B extends _cfg.$ConnectionTransport ?
    B
    :
    never
  :
  A extends _cfg.$AllowBareDDL ?
    B extends _cfg.$AllowBareDDL ?
    B
    :
    never
  :
never

function getSharedParentScalar<A extends $.ScalarType, B extends $.ScalarType>(a: A, b: B): A | B {
  a = (a as any).__casttype__ || a;
  b = (b as any).__casttype__ || b;
  if (a.__name__ === "std::number") {
    if(b.__name__ === "std::number") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "users::RepStatus") {
    if(b.__name__ === "users::RepStatus") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "users::Platform") {
    if(b.__name__ === "users::Platform") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "users::InfractionType") {
    if(b.__name__ === "users::InfractionType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "training::Selectability") {
    if(b.__name__ === "training::Selectability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "training::LocationName") {
    if(b.__name__ === "training::LocationName") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "training::AnswerType") {
    if(b.__name__ === "training::AnswerType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::VersionStage") {
    if(b.__name__ === "sys::VersionStage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionIsolation") {
    if(b.__name__ === "sys::TransactionIsolation") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionDeferrability") {
    if(b.__name__ === "sys::TransactionDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionAccessMode") {
    if(b.__name__ === "sys::TransactionAccessMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::QueryType") {
    if(b.__name__ === "sys::QueryType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::OutputFormat") {
    if(b.__name__ === "sys::OutputFormat") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::uuid") {
    if(b.__name__ === "std::uuid") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::str") {
    if(b.__name__ === "std::str") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::timestamptz") {
    if(b.__name__ === "std::pg::timestamptz") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::timestamp") {
    if(b.__name__ === "std::pg::timestamp") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::json") {
    if(b.__name__ === "std::pg::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::interval") {
    if(b.__name__ === "std::pg::interval") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::date") {
    if(b.__name__ === "std::pg::date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::http::Method") {
    if(b.__name__ === "std::net::http::Method") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::RequestState") {
    if(b.__name__ === "std::net::RequestState") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::RequestFailureKind") {
    if(b.__name__ === "std::net::RequestFailureKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::json") {
    if(b.__name__ === "std::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int64") {
    if(b.__name__ === "std::int64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int32") {
    if(b.__name__ === "std::int32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int16") {
    if(b.__name__ === "std::int16") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::document") {
    if(b.__name__ === "std::fts::document") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::Weight") {
    if(b.__name__ === "std::fts::Weight") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::PGLanguage") {
    if(b.__name__ === "std::fts::PGLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::LuceneLanguage") {
    if(b.__name__ === "std::fts::LuceneLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::Language") {
    if(b.__name__ === "std::fts::Language") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::ElasticLanguage") {
    if(b.__name__ === "std::fts::ElasticLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float64") {
    if(b.__name__ === "std::float64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float32") {
    if(b.__name__ === "std::float32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::enc::Base64Alphabet") {
    if(b.__name__ === "std::enc::Base64Alphabet") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::duration") {
    if(b.__name__ === "std::duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::decimal") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::datetime") {
    if(b.__name__ === "std::datetime") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::relative_duration") {
    if(b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "std::cal::date_duration") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_time") {
    if(b.__name__ === "std::cal::local_time") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_datetime") {
    if(b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "std::cal::local_date") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_date") {
    if(b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "std::cal::local_date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::date_duration") {
    if(b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "std::cal::date_duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bytes") {
    if(b.__name__ === "std::bytes") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bool") {
    if(b.__name__ === "std::bool") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bigint") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::JsonEmpty") {
    if(b.__name__ === "std::JsonEmpty") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::Endian") {
    if(b.__name__ === "std::Endian") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sign_in::ReasonCategory") {
    if(b.__name__ === "sign_in::ReasonCategory") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sign_in::LocationStatus") {
    if(b.__name__ === "sign_in::LocationStatus") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sign_in::LocationName") {
    if(b.__name__ === "sign_in::LocationName") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Volatility") {
    if(b.__name__ === "schema::Volatility") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TypeModifier") {
    if(b.__name__ === "schema::TypeModifier") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerTiming") {
    if(b.__name__ === "schema::TriggerTiming") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerScope") {
    if(b.__name__ === "schema::TriggerScope") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerKind") {
    if(b.__name__ === "schema::TriggerKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TargetDeleteAction") {
    if(b.__name__ === "schema::TargetDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::SourceDeleteAction") {
    if(b.__name__ === "schema::SourceDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::RewriteKind") {
    if(b.__name__ === "schema::RewriteKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::ParameterKind") {
    if(b.__name__ === "schema::ParameterKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::OperatorKind") {
    if(b.__name__ === "schema::OperatorKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::MigrationGeneratedBy") {
    if(b.__name__ === "schema::MigrationGeneratedBy") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::IndexDeferrability") {
    if(b.__name__ === "schema::IndexDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Cardinality") {
    if(b.__name__ === "schema::Cardinality") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessPolicyAction") {
    if(b.__name__ === "schema::AccessPolicyAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessKind") {
    if(b.__name__ === "schema::AccessKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "notification::Type") {
    if(b.__name__ === "notification::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "notification::Status") {
    if(b.__name__ === "notification::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "notification::DeliveryMethod") {
    if(b.__name__ === "notification::DeliveryMethod") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "notification::AllTargetTarget") {
    if(b.__name__ === "notification::AllTargetTarget") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ext::auth::WebhookEvent") {
    if(b.__name__ === "ext::auth::WebhookEvent") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ext::auth::JWTAlgo") {
    if(b.__name__ === "ext::auth::JWTAlgo") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ext::auth::FlowType") {
    if(b.__name__ === "ext::auth::FlowType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "event::EventType") {
    if(b.__name__ === "event::EventType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::memory") {
    if(b.__name__ === "cfg::memory") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::StoreMigrationSDL") {
    if(b.__name__ === "cfg::StoreMigrationSDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::SMTPSecurity") {
    if(b.__name__ === "cfg::SMTPSecurity") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::QueryStatsOption") {
    if(b.__name__ === "cfg::QueryStatsOption") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::QueryCacheMode") {
    if(b.__name__ === "cfg::QueryCacheMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::ConnectionTransport") {
    if(b.__name__ === "cfg::ConnectionTransport") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::AllowBareDDL") {
    if(b.__name__ === "cfg::AllowBareDDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
}

const implicitCastMap = new Map<string, Set<string>>([
  ["std::cal::date_duration", new Set(["std::cal::relative_duration"])],
  ["std::cal::local_date", new Set(["std::cal::local_datetime"])],
  ["std::bigint", new Set(["std::decimal"])],
]);
function isImplicitlyCastableTo(from: string, to: string): boolean {
  const _a = implicitCastMap.get(from),
        _b = _a != null ? _a.has(to) : null;
  return _b != null ? _b : false;
};

export type scalarLiterals =
  | number
  | string
  | boolean
  | bigint
  | Uint8Array
  | Date
  | gel.Duration
  | gel.ConfigMemory
  | Float32Array
  | gel.LocalDateTime
  | gel.LocalDate
  | gel.LocalTime
  | gel.RelativeDuration
  | gel.DateDuration
  | gel.Range<any> | gel.MultiRange<any>;

type getTsType<T extends $.BaseType> = T extends $.ScalarType
  ? T extends _std.$decimal | _stdfts.$document | _std.$json | _stdpg.$date | _stdpg.$interval | _stdpg.$json | _stdpg.$timestamp | _stdpg.$timestamptz | _std.$uuid
    ? never
    : T["__tstype__"]
  : T extends $.RangeType
  ? gel.Range<T['__element__']['__tstype__']>
  : T extends $.MultiRangeType
  ? gel.MultiRange<T['__element__']['__tstype__']>
  : never;
export type orScalarLiteral<T extends $.TypeSet> =
  | T
  | ($.BaseTypeSet extends T      ? scalarLiterals      : $.Cardinality extends T["__cardinality__"]        ? getTsType<T["__element__"]>        : $.computeTsTypeCard<            getTsType<T["__element__"]>,            T["__cardinality__"]          >);
export type scalarWithConstType<
  T extends $.ScalarType,
  TsConstType
> = $.ScalarType<
  T["__name__"],
  T["__tstype__"],
  T['__tsargtype__'],
  TsConstType
>;
export type literalToScalarType<T extends any> =
  T extends number ? scalarWithConstType<_std.$number, T> :
  T extends string ? scalarWithConstType<_std.$str, T> :
  T extends boolean ? scalarWithConstType<_std.$bool, T> :
  T extends bigint ? scalarWithConstType<_std.$bigint, T> :
  T extends Uint8Array ? scalarWithConstType<_std.$bytes, T> :
  T extends Date ? scalarWithConstType<_std.$datetime, T> :
  T extends gel.Duration ? scalarWithConstType<_std.$duration, T> :
  T extends gel.ConfigMemory ? scalarWithConstType<_cfg.$memory, T> :
  T extends gel.LocalDateTime ? scalarWithConstType<_stdcal.$local_datetime, T> :
  T extends gel.LocalDate ? scalarWithConstType<_stdcal.$local_date, T> :
  T extends gel.LocalTime ? scalarWithConstType<_stdcal.$local_time, T> :
  T extends gel.RelativeDuration ? scalarWithConstType<_stdcal.$relative_duration, T> :
  T extends gel.DateDuration ? scalarWithConstType<_stdcal.$date_duration, T> :
  T extends gel.Range<infer E> ? $.RangeType<literalToScalarType<E>> :
  T extends gel.MultiRange<infer E> ? $.MultiRangeType<literalToScalarType<E>> :
  $.BaseType;

type literalToTypeSet<T extends any> = T extends $.TypeSet
  ? T
  : $.$expr_Literal<literalToScalarType<T>>;

export type mapLiteralToTypeSet<T> = {
  [k in keyof T]: literalToTypeSet<T[k]>;
};

function literalToTypeSet(type: any): $.TypeSet {
  if (type && type.__element__) {
    return type;
  }
  if (typeof type === "number") {
    return literal.$getType("00000000-0000-0000-0000-0000000001ff")(type);
  }
  if (typeof type === "string") {
    return literal.$getType("00000000-0000-0000-0000-000000000101")(type);
  }
  if (typeof type === "boolean") {
    return literal.$getType("00000000-0000-0000-0000-000000000109")(type);
  }
  if (typeof type === "bigint") {
    return literal.$getType("00000000-0000-0000-0000-000000000110")(type);
  }
  if (type instanceof Uint8Array) {
    return literal.$getType("00000000-0000-0000-0000-000000000102")(type);
  }
  if (type instanceof Date) {
    return literal.$getType("00000000-0000-0000-0000-00000000010a")(type);
  }
  if (type instanceof gel.Duration) {
    return literal.$getType("00000000-0000-0000-0000-00000000010e")(type);
  }
  if (type instanceof gel.ConfigMemory) {
    return literal.$getType("00000000-0000-0000-0000-000000000130")(type);
  }
  if (type instanceof gel.LocalDateTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010b")(type);
  }
  if (type instanceof gel.LocalDate) {
    return literal.$getType("00000000-0000-0000-0000-00000000010c")(type);
  }
  if (type instanceof gel.LocalTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010d")(type);
  }
  if (type instanceof gel.RelativeDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000111")(type);
  }
  if (type instanceof gel.DateDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000112")(type);
  }
  throw new Error(`Cannot convert literal '${type}' into scalar type`);
}


export { getSharedParentScalar, isImplicitlyCastableTo, literalToTypeSet };
