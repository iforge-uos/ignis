// GENERATED by @gel/generate v0.6.2

import * as $ from "../../reflection";
import * as _ from "../../imports";
import type * as _cfg from "../cfg";
import type * as _std from "../std";
export type $halfvec = $.ScalarType<"ext::pgvector::halfvec", unknown>;
const halfvec: $.scalarTypeWithConstructor<$halfvec, never> = $.makeType<$.scalarTypeWithConstructor<$halfvec, never>>(_.spec, "4ba84534-188e-43b4-a7ce-cea2af0f405b", _.syntax.literal);
export type $halfvecλIAssignableBy = $halfvec | $vector | $halfvec | $sparsevec;

export type $sparsevec = $.ScalarType<"ext::pgvector::sparsevec", unknown>;
const sparsevec: $.scalarTypeWithConstructor<$sparsevec, never> = $.makeType<$.scalarTypeWithConstructor<$sparsevec, never>>(_.spec, "003e434d-cac2-430a-b238-fb39d73447d2", _.syntax.literal);
export type $sparsevecλIAssignableBy = $sparsevec | $vector | $halfvec | $sparsevec;

export type $vector = $.ScalarType<"ext::pgvector::vector", Float32Array, Float32Array | number[]>;
const vector: $.scalarTypeWithConstructor<$vector, number[]> = $.makeType<$.scalarTypeWithConstructor<$vector, number[]>>(_.spec, "9565dd88-04f5-11ee-a691-0b6ebe179825", _.syntax.literal);
export type $vectorλICastableTo = $vector | $halfvec;
export type $vectorλIAssignableBy = $vector | $halfvec | $vector | $sparsevec;

export type $ConfigλShape = $.typeutil.flatten<_cfg.$ExtensionConfigλShape & {
  "probes": $.PropertyDesc<_std.$int64, $.Cardinality.One, false, false, false, true>;
  "ef_search": $.PropertyDesc<_std.$int64, $.Cardinality.One, false, false, false, true>;
}>;
type $Config = $.ObjectType<"ext::pgvector::Config", $ConfigλShape, null, [
  ..._cfg.$ExtensionConfig['__exclusives__'],
], "ext::pgvector::Config">;
const $Config = $.makeType<$Config>(_.spec, "1d09ac5f-649a-5c54-b0ed-eb5eb9b819dc", _.syntax.literal);

const Config: $.$expr_PathNode<$.TypeSet<$Config, $.Cardinality.Many>, null> = _.syntax.$PathNode($.$toSet($Config, $.Cardinality.Many), null);

type l2_normalizeλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  $halfvec, $.cardutil.paramCardinality<P1>
>;
type l2_normalizeλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  $sparsevec, $.cardutil.paramCardinality<P1>
>;
type l2_normalizeλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  $vector, $.cardutil.paramCardinality<P1>
>;
function l2_normalize<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
): l2_normalizeλFuncExpr<P1>;
function l2_normalize<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
): l2_normalizeλFuncExpr2<P1>;
function l2_normalize<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
): l2_normalizeλFuncExpr3<P1>;
function l2_normalize(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::l2_normalize', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "003e434d-cac2-430a-b238-fb39d73447d2"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "9565dd88-04f5-11ee-a691-0b6ebe179825"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::l2_normalize",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type subvectorλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
  P3 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
> = $.$expr_Function<
  $halfvec, $.cardutil.multiplyCardinalities<$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>, $.cardutil.paramCardinality<P3>>
>;
type subvectorλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
  P3 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
> = $.$expr_Function<
  $vector, $.cardutil.multiplyCardinalities<$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>, $.cardutil.paramCardinality<P3>>
>;
function subvector<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
  P3 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
>(
  a: P1,
  i: P2,
  len: P3,
): subvectorλFuncExpr<P1, P2, P3>;
function subvector<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
  P3 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
>(
  a: P1,
  i: P2,
  len: P3,
): subvectorλFuncExpr2<P1, P2, P3>;
function subvector(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::subvector', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}, {typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}, {typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}], returnTypeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}, {typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}, {typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}], returnTypeId: "9565dd88-04f5-11ee-a691-0b6ebe179825"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::subvector",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type euclidean_distanceλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type euclidean_distanceλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type euclidean_distanceλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
function euclidean_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
  b: P2,
): euclidean_distanceλFuncExpr<P1, P2>;
function euclidean_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
  b: P2,
): euclidean_distanceλFuncExpr2<P1, P2>;
function euclidean_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
  b: P2,
): euclidean_distanceλFuncExpr3<P1, P2>;
function euclidean_distance(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::euclidean_distance', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}, {typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}, {typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}, {typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::euclidean_distance",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type neg_inner_productλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type neg_inner_productλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type neg_inner_productλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
function neg_inner_product<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
  b: P2,
): neg_inner_productλFuncExpr<P1, P2>;
function neg_inner_product<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
  b: P2,
): neg_inner_productλFuncExpr2<P1, P2>;
function neg_inner_product<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
  b: P2,
): neg_inner_productλFuncExpr3<P1, P2>;
function neg_inner_product(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::neg_inner_product', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}, {typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}, {typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}, {typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::neg_inner_product",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type cosine_distanceλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type cosine_distanceλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type cosine_distanceλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
function cosine_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
  b: P2,
): cosine_distanceλFuncExpr<P1, P2>;
function cosine_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
  b: P2,
): cosine_distanceλFuncExpr2<P1, P2>;
function cosine_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
  b: P2,
): cosine_distanceλFuncExpr3<P1, P2>;
function cosine_distance(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::cosine_distance', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}, {typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}, {typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}, {typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::cosine_distance",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type taxicab_distanceλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type taxicab_distanceλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
type taxicab_distanceλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>
>;
function taxicab_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
  b: P2,
): taxicab_distanceλFuncExpr<P1, P2>;
function taxicab_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
  b: P2,
): taxicab_distanceλFuncExpr2<P1, P2>;
function taxicab_distance<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
  b: P2,
): taxicab_distanceλFuncExpr3<P1, P2>;
function taxicab_distance(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::taxicab_distance', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}, {typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}, {typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}, {typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::taxicab_distance",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type euclidean_normλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.paramCardinality<P1>
>;
type euclidean_normλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.paramCardinality<P1>
>;
type euclidean_normλFuncExpr3<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.paramCardinality<P1>
>;
function euclidean_norm<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$halfvec>>,
>(
  a: P1,
): euclidean_normλFuncExpr<P1>;
function euclidean_norm<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$sparsevec>>,
>(
  a: P1,
): euclidean_normλFuncExpr2<P1>;
function euclidean_norm<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$vectorλICastableTo>>,
>(
  a: P1,
): euclidean_normλFuncExpr3<P1>;
function euclidean_norm(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::euclidean_norm', args, _.spec, [
    {args: [{typeId: "4ba84534-188e-43b4-a7ce-cea2af0f405b", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "003e434d-cac2-430a-b238-fb39d73447d2", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
    {args: [{typeId: "9565dd88-04f5-11ee-a691-0b6ebe179825", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::euclidean_norm",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};

type set_probesλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
> = $.$expr_Function<
  _std.$number, $.cardutil.paramCardinality<P1>
>;
function set_probes<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
>(
  num: P1,
): set_probesλFuncExpr<P1>;
function set_probes(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('ext::pgvector::set_probes', args, _.spec, [
    {args: [{typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}], returnTypeId: "00000000-0000-0000-0000-0000000001ff"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "ext::pgvector::set_probes",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};



export { halfvec, sparsevec, vector, $Config, Config };

type __defaultExports = {
  "halfvec": typeof halfvec;
  "sparsevec": typeof sparsevec;
  "vector": typeof vector;
  "Config": typeof Config;
  "l2_normalize": typeof l2_normalize;
  "subvector": typeof subvector;
  "euclidean_distance": typeof euclidean_distance;
  "neg_inner_product": typeof neg_inner_product;
  "cosine_distance": typeof cosine_distance;
  "taxicab_distance": typeof taxicab_distance;
  "euclidean_norm": typeof euclidean_norm;
  "set_probes": typeof set_probes
};
const __defaultExports: __defaultExports = {
  "halfvec": halfvec,
  "sparsevec": sparsevec,
  "vector": vector,
  "Config": Config,
  "l2_normalize": l2_normalize,
  "subvector": subvector,
  "euclidean_distance": euclidean_distance,
  "neg_inner_product": neg_inner_product,
  "cosine_distance": cosine_distance,
  "taxicab_distance": taxicab_distance,
  "euclidean_norm": euclidean_norm,
  "set_probes": set_probes
};
export default __defaultExports;
