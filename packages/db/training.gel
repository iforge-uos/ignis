module training {
    scalar type LocationName extending enum<
        MAINSPACE,
        HEARTSPACE,
        GEORGE_PORTER,
    >;

    type Training extending default::Auditable {
        required name: str;

        # things for the training app
        required enabled: bool {
            default := true;
        }
        required description: str;
        training_lockout: duration;
        multi pages: TrainingPage;
        multi questions: Question;
        # should be required multi
        multi sections := (  # polymorphism my beloved
            select .pages union .questions
            order by .index
        );
        icon_url: str;

        # things for the UI
        multi locations: LocationName;
        required compulsory: bool {
            default := false;
        }
        required in_person: bool {
            annotation description := "Whether this training requires in person training."
        }
        rep: Training {
            annotation description := "The associated training that reps should have to supervise this. Empty if the training is for reps."
        }
        expires_after: duration;

        # multi history: Training {
        #     # @reset_training: bool {
        #     #     annotation description := "Whether this was a large enough change to "
        #     # }
        #     annotation description := "We keep track of these for the edit functionality."
        #     rewrite update using (

        #     )
        # }

        index fts::index on (
            fts::with_options(
                .name,
                language := fts::Language.eng
            )
        );
        constraint exclusive on ((.name, .rep));

        access policy desk_or_higher_edit
            allow all
            using (
                with user := global default::user,
                select (
                    exists ({"Admin"} intersect user.roles.name)
                    or (user is users::Rep and exists ({"H&S"} intersect user[is users::Rep].teams.name))
                ) ?? false
            ) {
                errmessage := "Only H&S members or admins can update training"
            };
         access policy allow_reps_view_rep  # FIXME this doesn't work
            deny all
            using (
                with user := global default::user,
                select (
                    user is not users::Rep and not exists .rep
                ) ?? false
            ) {
                errmessage := "Only reps can view rep training"
            };
        access policy select_if_completed_basic
            allow select
            using (
                with user := global default::user,
                select (
                    not exists .rep and __subject__ in user.training.rep
                )
            ) {
                errmessage := "Only H&S members or admins can update training"
            };
        access policy everyone
            allow select
    }

    abstract type Interactable {
        required parent: Training;  # edgedb/edgedb#7209
        # required parent := (
        #     select assert_exists(assert_single(Training filter __subject__ in .sections))
        # }  # ideal solution is a compute but we need this now
        required index: int16;
        required content: str;
        required enabled: bool {
            default := true;
        }
        constraint exclusive on ((.parent, .index));

        # TODO consider adding stats? e.g. failure rate
        access policy desk_or_higher_edit
            allow all
            using (
                with user := global default::user,
                select (
                    exists ({"Admin"} intersect user.roles.name)
                    or user is users::Rep and exists ({"H&S"} intersect user[is users::Rep].teams.name)
                ) ?? false
            ) {
                errmessage := "Only H&S members or admins can update training"
            };
        access policy everyone
            allow select
    }

    type TrainingPage extending Interactable {
        required name: str;
        duration: duration;
    }

    scalar type AnswerType extending enum<
        `SINGLE`,
        MULTI,
    >;

    type Question extending Interactable {
        required type: AnswerType;
        required multi answers: Answer;
    }

    type Answer {
        required content: str;
        required correct: bool {
            default := false;
        }
        description: str {
            annotation description := "The text shown after a user passes their answer giving a lil' explanation about whatever they said."
        }

        access policy h_and_s_or_higher
            allow all
            using (
                with user := global default::user,
                select (
                    exists ({"Admin"} intersect user.roles.name)
                    or user is users::Rep and exists ({"H&S"} intersect user[is users::Rep].teams.name)
                ) ?? false
            ) {
                errmessage := "Only H&S members or admins can update training"
            };
        access policy everyone
            allow select
    }

    type Session extending default::Auditable {
        required user: users::User;
        required training: Training;
        required index: int16 {
            annotation description := "The `Interactable.index` for the section user is currently on.";
            default := 0;
        }
        next_section := (
             select .training.sections
             filter .enabled and .index > __source__.index
             order by .index
             limit 1
        );

        constraint exclusive on ((.user, .training));  # must be kept inline with startTraining's unlessConflict

        access policy allow_self_or_admin
            allow all
            using (
                with user := global default::user,
                select exists ({"Admin"} intersect user.roles.name) or user ?= .user
            ) {
                errmessage := "Only self/admins can view sessions"
            };
        access policy allow_reps
            allow insert
            using (
                with user := global default::user,
                select not exists .training.rep or exists ({"Rep"} intersect user.roles.name)
            ) {
                errmessage := "Only reps can complete rep training"
            }
    }
}